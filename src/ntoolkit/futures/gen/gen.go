package main

import (
	"bytes"
	"flag"
	"html/template"
	"io/ioutil"
	"log"
	"os"
)

func main() {
	packageNamePtr := flag.String("packageName", "", "The name of package for the generated file, eg. mypackage")
	typeImportPtr := flag.String("typeImport", "", "The import statement for the type, eg. testing")
	typeNamePtr := flag.String("typeName", "", "The extension for the generated class, eg. T -> DeferredValueT")
	typeValuePtr := flag.String("typeValue", "", "The literal value to use for the type, eg. *testing.T")
	outputPtr := flag.String("output", "", "The output filename, eg. DeferredValue.go")
	flag.Parse()

	args := &templateData{
		PackageName: *packageNamePtr,
		TypeImport:  *typeImportPtr,
		TypeValue:   *typeValuePtr,
		TypeName:    *typeNamePtr,
	}

	result := renderTemplate(args)

	path := *outputPtr
	if path == "" {
		log.Fatalf("Invalid output path")
		os.Exit(1)
	}

	err := ioutil.WriteFile(path, []byte(result), 0644)
	if err != nil {
		log.Fatalf("Failed to generate file: %s\n", err.Error())
	}
}

type templateData struct {

	// PackageName -> package ...
	PackageName string

	// TypeImport -> import "..."
	TypeImport string

	// TypeName -> DeferredValueNAME
	TypeName string

	// TypeValue -> Resolve(value ...)
	TypeValue string
}

func renderTemplate(args *templateData) string {
	tmpl, err := template.New("typedDeferredObject").Parse(templateText)
	if err != nil {
		log.Fatalf("parsing: %s", err)
	}

	var doc bytes.Buffer
	err = tmpl.Execute(&doc, args)
	if err != nil {
		log.Fatalf("execution: %s", err)
	}

	return doc.String()
}

var templateText = `
// Generated by ntoolkit/futures
package {{.PackageName}}

import "ntoolkit/futures"
{{if .TypeImport}}
import "{{.TypeImport}}"
{{end}}

type Deferred{{.TypeName}} struct {
	DeferredValue futures.Promise
}

func (promise *Deferred{{.TypeName}}) init() {
	if promise.DeferredValue == nil {
		promise.DeferredValue = &futures.DeferredValue{}
	}
}

func (promise *Deferred{{.TypeName}}) Resolve(result {{.TypeValue}}) {
	promise.init()
	promise.DeferredValue.PResolve(result)
}

func (promise *Deferred{{.TypeName}}) Reject(err error) {
	promise.init()
	promise.DeferredValue.PReject(err)
}

func (promise *Deferred{{.TypeName}}) Errors() []error {
	promise.init()
	return promise.DeferredValue.PErrors()
}

func (promise *Deferred{{.TypeName}}) Then(resolve func({{.TypeValue}}), reject func(error)) *Deferred{{.TypeName}} {
	promise.init()
	promise.DeferredValue.PThen(func(value interface{}) {
		if v, ok := value.({{.TypeValue}}); ok {
			resolve(v)
		} else {
		  panic("Invalid value used to resolve Deferred{{.TypeName}}")
		}
	}, reject)
	return promise
}

func (promise *Deferred{{.TypeName}}) PThen(result func(interface{}), reject func(error)) futures.Promise {
	promise.init()
	return promise.DeferredValue.PThen(result, reject)
}

func (promise *Deferred{{.TypeName}}) PErrors() []error {
	promise.init()
	return promise.DeferredValue.PErrors()
}

func (promise *Deferred{{.TypeName}}) PResolve(result interface{}) {
	promise.init()
	promise.DeferredValue.PResolve(result)
}

func (promise *Deferred{{.TypeName}}) PReject(err error) {
	promise.init()
	promise.DeferredValue.PReject(err)
}
`
